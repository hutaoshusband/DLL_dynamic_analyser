use crate::config::MonitorConfig;
use serde_json;
use std::{mem, sync::mpsc, thread, time::Duration};
use widestring::U16CString;
use windows_sys::Win32::{
    Foundation::{CloseHandle, GetLastError, INVALID_HANDLE_VALUE, BOOL},
    Storage::FileSystem::{CreateFileW, ReadFile, WriteFile, PIPE_ACCESS_DUPLEX},
    System::{
        Diagnostics::Debug::{CheckRemoteDebuggerPresent, IsDebuggerPresent},
        Diagnostics::ToolHelp::{
            CreateToolhelp32Snapshot, Process32FirstW, Process32NextW, PROCESSENTRY32W,
            TH32CS_SNAPPROCESS,
        },
        LibraryLoader::LoadLibraryW,
        Threading::GetCurrentProcess,
    },
};

const DLL_NAME: &str = "monitor_lib.dll";

#[test]
fn test_malware_hooks_and_rate_limiting() {
    // 1. Load the monitor DLL. It will start a pipe server and wait for a config.
    let mut dll_path = std::env::current_exe().unwrap();
    dll_path.pop(); // -> target/x86_64-pc-windows-gnu/debug/deps
    dll_path.pop(); // -> target/x86_64-pc-windows-gnu/debug
    dll_path.push(DLL_NAME);

    assert!(dll_path.exists(), "monitor_lib.dll not found at {:?}. Make sure it's built first.", dll_path);

    let dll_path_wide = U16CString::from_os_str(&dll_path).unwrap();
    let dll_handle = unsafe { LoadLibraryW(dll_path_wide.as_ptr()) };
    assert_ne!(dll_handle, 0, "Failed to load monitor_lib.dll. Error: {}", unsafe { GetLastError() });

    // Give the DLL time to create its pipe server.
    thread::sleep(Duration::from_millis(500));

    // 2. Connect to the DLL's pipe server as a client.
    let pid = std::process::id();
    let pipe_name = format!(r"\\.\pipe\cs2_monitor_{}", pid);
    let wide_pipe_name = U16CString::from_str(&pipe_name).unwrap();
    let pipe_handle = unsafe {
        CreateFileW(
            wide_pipe_name.as_ptr(),
            PIPE_ACCESS_DUPLEX,
            0,
            std::ptr::null(),
            3, // OPEN_EXISTING
            0,
            0,
        )
    };
    assert_ne!(pipe_handle, INVALID_HANDLE_VALUE, "Test failed to connect to the DLL's named pipe. Error: {}", unsafe { GetLastError() });

    // 3. Send the configuration to unblock the DLL and enable all features for the test.
    let config = MonitorConfig {
        api_hooks_enabled: true,
        iat_scan_enabled: true,
        string_dump_enabled: true,
        vmp_dump_enabled: true,
        manual_map_scan_enabled: true,
    };
    let config_json = serde_json::to_string(&config).unwrap();
    let mut bytes_written = 0;
    let success = unsafe {
        WriteFile(pipe_handle, config_json.as_ptr(), config_json.len() as u32, &mut bytes_written, std::ptr::null_mut())
    } != 0;
    assert!(success, "Test failed to write config to pipe. Error: {}", unsafe { GetLastError() });

    // 4. Start a thread to listen for logs coming back from the DLL.
    let (log_sender, log_receiver) = mpsc::channel();
    thread::spawn(move || {
        let mut buffer = [0u8; 4096];
        loop {
            let mut bytes_read = 0;
            let success = unsafe {
                ReadFile(pipe_handle, buffer.as_mut_ptr() as _, buffer.len() as u32, &mut bytes_read, std::ptr::null_mut())
            } != 0;
            if success && bytes_read > 0 {
                let message = String::from_utf8_lossy(&buffer[..bytes_read as usize]);
                for line in message.lines().filter(|l| !l.trim().is_empty()) {
                    if log_sender.send(line.to_string()).is_err() {
                        break; // Main thread has disconnected.
                    }
                }
            } else {
                break; // Pipe closed or error.
            }
        }
        unsafe { CloseHandle(pipe_handle) };
    });

    // Give hooks time to initialize after receiving config.
    thread::sleep(Duration::from_millis(500));
    // Clear any logs generated during initialization.
    while log_receiver.try_recv().is_ok() {}

    // 5. Call hooked functions to generate test events.
    for _ in 0..10 {
        unsafe { IsDebuggerPresent() };
        thread::sleep(Duration::from_millis(10));
    }
    thread::sleep(Duration::from_secs(6)); // Wait for rate-limiter cooldown.
    unsafe { IsDebuggerPresent() };

    let mut is_present: BOOL = 0;
    unsafe { CheckRemoteDebuggerPresent(GetCurrentProcess(), &mut is_present) };

    unsafe {
        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if snapshot != INVALID_HANDLE_VALUE {
            let mut pe32: PROCESSENTRY32W = std::mem::zeroed();
            pe32.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;
            if Process32FirstW(snapshot, &mut pe32) != 0 {
                Process32NextW(snapshot, &mut pe32);
            }
            CloseHandle(snapshot);
        }
    }

    // 6. Collect and verify logs.
    thread::sleep(Duration::from_secs(2)); // Allow ample time for logs to be processed.

    let logs: Vec<String> = log_receiver.try_iter().collect();

    println!("Received {} logs.", logs.len());
    logs.iter().for_each(|log| println!("- {}", log));

    assert_eq!(logs.iter().filter(|l| l.contains("IsDebuggerPresent")).count(), 2, "Expected 2 IsDebuggerPresent logs due to rate limiting");
    assert_eq!(logs.iter().filter(|l| l.contains("CheckRemoteDebuggerPresent")).count(), 1, "Expected 1 CheckRemoteDebuggerPresent log");
    assert_eq!(logs.iter().filter(|l| l.contains("CreateToolhelp32Snapshot")).count(), 1, "Expected 1 CreateToolhelp32Snapshot log");
    assert_eq!(logs.iter().filter(|l| l.contains("Process32FirstW")).count(), 1, "Expected 1 Process32FirstW log");
    assert_eq!(logs.iter().filter(|l| l.contains("Process32NextW")).count(), 1, "Expected 1 Process32NextW log");
}