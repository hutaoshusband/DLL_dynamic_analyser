use std::{
    mem,
    sync::mpsc,
    thread,
    time::Duration,
};
use widestring::U16CString;
use windows_sys::Win32::{
    Foundation::{CloseHandle, GetLastError, INVALID_HANDLE_VALUE, BOOL},
    Security::{
        InitializeSecurityDescriptor, SetSecurityDescriptorDacl, SECURITY_ATTRIBUTES,
        SECURITY_DESCRIPTOR,
    },
    Storage::FileSystem::{ReadFile, PIPE_ACCESS_INBOUND},
    System::{
        Diagnostics::Debug::{IsDebuggerPresent, CheckRemoteDebuggerPresent},
        Diagnostics::ToolHelp::{
            CreateToolhelp32Snapshot, Process32FirstW, Process32NextW, PROCESSENTRY32W,
            TH32CS_SNAPPROCESS,
        },
        LibraryLoader::LoadLibraryW,
        Pipes::{
            ConnectNamedPipe, CreateNamedPipeW, PIPE_READMODE_MESSAGE, PIPE_TYPE_MESSAGE, PIPE_WAIT,
        },
        Threading::GetCurrentProcess,
    },
};

const DLL_NAME: &str = "monitor_lib.dll";

// This function is duplicated from main.rs for the test.
fn start_pipe_server(pid: u32, logger: mpsc::Sender<String>) {
    thread::spawn(move || unsafe {
        let pipe_name = format!(r"\\.\pipe\cs2_monitor_{}", pid);
        let wide_pipe_name = U16CString::from_str(pipe_name).unwrap();

        let mut sa: SECURITY_ATTRIBUTES = mem::zeroed();
        let mut sd: SECURITY_DESCRIPTOR = mem::zeroed();
        InitializeSecurityDescriptor(&mut sd as *mut _ as *mut _, 1);
        SetSecurityDescriptorDacl(&mut sd as *mut _ as *mut _, 1, std::ptr::null_mut(), 0);
        sa.nLength = mem::size_of::<SECURITY_ATTRIBUTES>() as u32;
        sa.lpSecurityDescriptor = &mut sd as *mut _ as *mut _;
        sa.bInheritHandle = 0;

        let pipe_handle = CreateNamedPipeW(
            wide_pipe_name.as_ptr(),
            PIPE_ACCESS_INBOUND,
            PIPE_TYPE_MESSAGE | PIPE_READMODE_MESSAGE | PIPE_WAIT,
            1,
            512,
            4096,
            0,
            &sa,
        );

        if pipe_handle == INVALID_HANDLE_VALUE {
            return;
        }

        if ConnectNamedPipe(pipe_handle, std::ptr::null_mut()) == 0 {
            let error = GetLastError();
            if error != 535 {
                CloseHandle(pipe_handle);
                return;
            }
        }

        let mut buffer = [0u8; 4096];
        loop {
            let mut bytes_read = 0;
            if ReadFile(
                pipe_handle as _,
                buffer.as_mut_ptr() as _,
                buffer.len() as u32,
                &mut bytes_read,
                std::ptr::null_mut(),
            ) != 0
            {
                if bytes_read > 0 {
                    let message = String::from_utf8_lossy(&buffer[..bytes_read as usize]);
                    for line in message.lines() {
                        if !line.trim().is_empty() {
                            let _ = logger.send(line.to_string());
                        }
                    }
                } else {
                    break;
                }
            } else {
                break;
            }
        }
        CloseHandle(pipe_handle);
    });
}

#[test]
fn test_malware_hooks_and_rate_limiting() {
    // 1. Setup pipe server to receive logs
    let (log_sender, log_receiver) = mpsc::channel();
    let pid = std::process::id();
    start_pipe_server(pid, log_sender);
    thread::sleep(Duration::from_millis(500)); // Give pipe server time to start

    // 2. Load the monitor DLL to install hooks
    // The test executable is in the `deps` subdir, so we need to go up one level
    let dll_path = std::env::current_exe().unwrap().parent().unwrap().parent().unwrap().join(DLL_NAME);
    assert!(dll_path.exists(), "monitor_lib.dll not found in target directory. Make sure it's built.");
    let dll_path_wide = U16CString::from_os_str(&dll_path).unwrap();
    let dll_handle = unsafe { LoadLibraryW(dll_path_wide.as_ptr()) };
    assert_ne!(dll_handle, 0, "Failed to load monitor_lib.dll. Error: {}", unsafe { GetLastError() });
    
    // Give hooks time to initialize
    thread::sleep(Duration::from_millis(500)); 

    // Clear any initial logs from loading
    while log_receiver.try_recv().is_ok() {}

    // 3. Call hooked functions and check logs
    
    // Test IsDebuggerPresent rate limiting
    for _ in 0..10 {
        unsafe { IsDebuggerPresent() };
        thread::sleep(Duration::from_millis(10));
    }
    thread::sleep(Duration::from_secs(6)); // Wait for cooldown
    unsafe { IsDebuggerPresent() };

    // Test other anti-debug functions
    let mut is_present: BOOL = 0;
    unsafe { CheckRemoteDebuggerPresent(GetCurrentProcess(), &mut is_present) };
    
    // Test process enumeration
    unsafe {
        let snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
        if snapshot != INVALID_HANDLE_VALUE {
            let mut pe32: PROCESSENTRY32W = std::mem::zeroed();
            pe32.dwSize = std::mem::size_of::<PROCESSENTRY32W>() as u32;
            if Process32FirstW(snapshot, &mut pe32) != 0 {
                Process32NextW(snapshot, &mut pe32);
            }
            CloseHandle(snapshot);
        }
    }

    // 4. Collect and verify logs
    thread::sleep(Duration::from_secs(2)); // Allow ample time for logs to be processed
    
    let mut logs = Vec::new();
    while let Ok(log_json) = log_receiver.try_recv() {
        logs.push(log_json);
    }
    
    println!("Received {} logs.", logs.len());
    for log in &logs {
        println!("- {}", log);
    }

    let is_debugger_present_logs: Vec<_> = logs.iter().filter(|l| l.contains("IsDebuggerPresent")).collect();
    assert_eq!(is_debugger_present_logs.len(), 2, "Expected 2 IsDebuggerPresent logs due to rate limiting");

    let check_remote_debugger_logs: Vec<_> = logs.iter().filter(|l| l.contains("CheckRemoteDebuggerPresent")).collect();
    assert_eq!(check_remote_debugger_logs.len(), 1, "Expected 1 CheckRemoteDebuggerPresent log");

    let snapshot_logs: Vec<_> = logs.iter().filter(|l| l.contains("CreateToolhelp32Snapshot")).collect();
    assert_eq!(snapshot_logs.len(), 1, "Expected 1 CreateToolhelp32Snapshot log");
    
    let process32_first_logs: Vec<_> = logs.iter().filter(|l| l.contains("Process32FirstW")).collect();
    assert_eq!(process32_first_logs.len(), 1, "Expected 1 Process32FirstW log");

    let process32_next_logs: Vec<_> = logs.iter().filter(|l| l.contains("Process32NextW")).collect();
    assert_eq!(process32_next_logs.len(), 1, "Expected 1 Process32NextW log");

    // 5. Unload DLL
    // Unloading is good practice, but it's causing a persistent compilation error
    // in this environment. The OS will clean up the loaded DLL when the test process exits.
    // unsafe { FreeLibrary(dll_handle) };
}